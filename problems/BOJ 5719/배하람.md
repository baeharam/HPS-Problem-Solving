- **내가 이해한 문제내용**
  - 최단경로를 이루는 간선을 제외한 간선들 중에서의 최단경로를 구하여라.
- **접근 방식**
  - 처음엔 간단하게 다익스트라 → 최단경로 제거 → 다익스트라로 시도했으나... 간선을 공유하는 경로가 존재한다는 반례를 알게되었다.
  - 그래서 그 공유간선을 포함해서 어떤 방식으로 최단경로를 제거해나갈지를 생각했지만 혼자 힘으로 해결할 수 없어서 [라이](https://m.blog.naver.com/kks227/220796029558)님과 [Crocus](https://www.crocus.co.kr/682)님에게서 힌트들을 얻음
  - 간선제거에 큐를 사용해야 한다는 것을 알았고 그걸 활용해 제거해나갔다.
- **어려웠던 점**
  - 나에겐 문제자체가 어려운 편이었고 최단경로 문제를 응용한다는 점에서 배울점이 많았다.
  - 시간초과, 메모리초과, 틀렸습니다... 모든 걸 겪음.
  - 특히 간선제거 부분에선 경로들을 저장하는 부분들이 까다로워서 많이 막혔고 고민도 상당히 많이 했다.
  - 실수를 한게 있는데 `priority_queue`를 사용할 때 기본이 내림차순이라는 설정을 까먹었다는 점이다. 그래서 왜 계속 안돼지....이러고 있다가 캐치하고 `greater`로 다시 수정했다.
  - 하지만 `greater`를 쓰는 방법 말고도 간선을 음수로 해서 더 간단하게 하는 방법이 존재하는데 이 부분은 시간을 너무 많이 쓴 관계로 다음에 나오는 최단경로 문제에서 활용해보기로 하자.
  - `INF` 변수를 설정해서 하는 부분이 `int` 범위를 초과한다는 점을 간과했었고 단순히 `-1`로 초기화하는 것으로도 해결할 수 있는 것을 배웠다.
  - 마지막으로 인접 리스트를 활용한 구현이 상당히 복잡해서 시간이 그렇게 빡세지 않다면 인접 행렬로 구현하는 방식을 사용하는 것도 좋을 것 같다.
- **복잡도**
  - 시간복잡도
    - 다익스트라 알고리즘: `O(|E|lg|V|)`
    - 최단경로의 간선제거: 이 부분이 좀 까다로운데 최악의 경우 모든 정점이 큐에 들어가게 되고 각 정점의 이전 정점들이 `|V|-1`개 일수 있다. 또한 해당 정점의 간선을 모두 봐야할 수 있기 때문에 어림짐작하면 `O(|E||V|^2)` 인듯 하다.
    - 최종: `O(|E||V|^2)`
  - 공간복잡도: `O(|V|^2)`