# 내가 이해한 문제내용
s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn 위의 식을 이용해서 인접한 비트 수를 구할 수 있는데,
역으로 인접한 비트수와 문자열의 길이가 주어진다면 가능한 문자열은 몇가지 인지 구하는 문제

# 접근방법
- 생각의 흐름
s1*s2 + s2*s3 + s3*s4 + ... + sn-1 * sn

Sn = sn-1 * sn (n >= 2)이라고한다면,
S2 + S3 + S4 + .... + Sn 가 된다.
각 항 Sk은 0또는 1의 값을 가질 수 있으므로, 경우의 수는 C(n-1,k)가 됩니다.
하지만 Sk는 sk-1 * sk 값이기 때문에
값이 1이라면 sk-1과 sk 둘다 1이기 때문에 문제가 없지만,
값이 0이라면 sk-1 = 0 and sk = 1,
          sk-1 = 1 and sk = 0,
          sk-1 = 0 and sk = 0 의 3가지 경우가 다시 나온다.

          따라서, Sk가 0인 값에 대하여 가능한지 검사를 해줘야 한다.

예를 들어 (n,k) = (5,2)인 경우를 살펴보면
C(4,2) = 6
0011 0101 0110 1001 1010 1100

i) 0011 => s1,s2,s3는 0이므로 계산해줘야함
  ???11
  s1과 s2중 적어도 하나는 0이어야한다.
  s2과 s3중 적어도 하나는 0이어야한다.

  인줄알았으나, 수학문제가 아니고 DP문제엿다. ㅎㅎㅎㅎ


  -------------------------------------------------


맨 뒤의 수가 1이면 뒤에 다시 1을 붙였을 때, 인접 비트의 개수는 1 더해진다.
0이라면 0 또는 1을 붙여도 인접 비트의 개수는 변화가 없다는 것을 알 수 있다.

위와 같은 경우를 바탕으로 만들 수 있는 점화식은 다음과 같다.
인접 비트 개수가 k개이고, n번째 수가 0일 때 수열의 개수
dp[n][k][0] = dp[n - 1][k][0] + dp[n - 1][k][1];
dp[n][k][1] = dp[n - 1][k-1][1] + dp[n - 1][k][0];


그래서 N, K에 대해서 0으로 끝날 때의 경우의 수와 1로 끝날 때의 경우의 수를 더하면 답.


- 알고리즘
DP


# 어려웠던 점 및 새로운 알고리즘
생각도 안하고 덤벼들어서 그냥 무식하게 순열과 조합으로 접근했다.. 정신을 좀 차리고 문제분석을 해야 할 것 같다.


# 복잡도
- 시간 복잡도: O(N^2)
- 공간 복잡도: O(N^2)
