- **내가 이해한 문제내용**
  - 모든 컴퓨터들을 연결하고, 그 비용이 가장 적게 하라.
- **접근 방식**
  - 하람이가 다 가르쳐 주고 시작한 문제라 크루스칼 알고리즘을 쓰면 쉽게 풀리는 문제다. 사실 문제자체가 크루스칼 이다.
- **어려웠던 점**
  - 음...
- **복잡도**
  E를 변의 개수라 하고, {\displaystyle V} V를 꼭짓점의 개수라고 하자. 크러스컬 알고리즘은 {\displaystyle {\color {Blue}O}(E\log V)} {\color {Blue}O}(E\log V) 시간 안에 동작한다고 증명될 수 있다. 간단한 자료 구조가 쓰인다면 {\displaystyle O(E\log V)} O(E\log V) 안에 동작한다. 이 동작 시간은 동일한데, 그 까닭은 다음과 같다:

{\displaystyle E} E는 최대 {\displaystyle V^{2}} V^{2} 개일 수 있다. {\displaystyle \log V^{2}=2\log V} \log V^{2}=2\log V 는 {\displaystyle O(\log V)} O(\log V)이다.
홀로 떨어진 꼭짓점들을 무시한다면 (그들 각각은 그만의 최소 비용 생성나무가 된다.), {\displaystyle V\leq 2E} V\leq 2E이다. 그러므로 {\displaystyle \log V} \log V 는 {\displaystyle O(\log E)} O(\log E)이다.
이러한 시간 복잡도 한계는 다음과 같은 방법으로 도달할 수 있다. 변들을 그 가중치 순으로 {\displaystyle O(E\log E)} O(E\log E) 시간 내에 정렬한다. 정렬을 함으로써, "집합 S로부터 최소 가중치를 갖는 변을 제거한다"는 동작이 상수 시간에 행해질 수 있게 된다. 디스조인트-셋 자료 구조(유니온 파인드: 결합과 검색)를 이용하여 어떤 꼭짓점이 어떤 콤포넌트(component)에 속하는 지 추적한다. 디스조인트-셋 찾기(find) 동작 두 번에 {\displaystyle O(E)} O(E) 시간이 걸린다. 각 변이 각각 한 유니언(union) 안에 있다고 가정하면 말이다. 간단한 디스조인트-셋 자료 구조인 랭크에 의한 합집합을 사용하는 디스조인트-셋 숲(disjoint-set forest with union by rank)를 쓰더라도, {\displaystyle O(E)} O(E) 개의 동작이 {\displaystyle O(E\log V)} O(E\log V) 시간 안에 행해진다. 그러므로 총 시간 복잡도는 {\displaystyle O(E\log E)=O(E\log V)} O(E\log E)=O(E\log V)가 된다.

변들이 이미 정렬되어 있거나 선형 시간(linear time, {\displaystyle O(E)} O(E)) 안에 정렬될 수 있다면(예를 들어 카운팅 정렬, 라딕스 정렬), 크러스컬 알고리즘은 좀 더 고도의 디스조인트-셋 자료 구조를 사용할 수 있다. 이때 동작 시간 복잡도는 {\displaystyle O(E\alpha (V))} O(E\alpha (V))가 되는데, 여기서 {\displaystyle \alpha } \alpha  는 아주 느리게 증가하는 단일-값 애커만 함수의 역함수를 말한다.

