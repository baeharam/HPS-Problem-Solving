# 내가 이해한 문제내용
여러 행렬의 곱셈이 있을 때 행렬의 곱은 결합법칙이 성립하기 때문에 무엇을 먼저 곱하던 값은 똑같다.
하지만 무엇을 먼저 곱하느냐에 따라 연산횟수가 달라진다. 이때 가장 연산을 적게하는 경우를 구하라

# 접근방법
- 생각의 흐름
저번 문제로 깨달은 사실은 문제가 복잡하고 감을 못잡겠을 때는 브루트 포스 혹은 문제를 잘게 쪼개야한다는 것을 배웠다.
연산횟수가 2^31-1로 꽤 크니, 브루트 포스는 아니고 분할정복이나 DP인데 subproblem이 각각 다르니 DP로 방향을 잡고 접근을 했다.

예시를 들자면, 행렬이 3개 주어졌다고 하면,
A1 행렬은 행 d0 열 d1
A2 행렬은 행 d1 열 d2
A3 행렬은 행 d2 열 d3 이기 때문에
  (A1A2)A3의 연산 횟수는 d0d1d2 + d0d2d3가 된다.

  또한, 행렬이 몇개이던지 두 부분으로 나눌 수 있다.
  즉, n개의 행렬이 있을 때의 계산횟수는 M[1][n] = min(M[1][k] + M[k+1][n] + d0 * dk * dn)

  이것을 n번 반복하면 최솟값이 나온다.

  for (int i = 2; i < n; i++) {
	 answer = min(M[1][n] = min(M[1][k] + M[k+1][n] + d0 * dk * dn);
    }
  


- 알고리즘
Dynamic programming


# 어려웠던 점 및 새로운 알고리즘
진짜 DP는 식세우는게 너무 어렵다. 많이 풀어보는것 밖에 답이 없는거 같다.



# 복잡도
- 시간 복잡도: O(N^3)
- 공간 복잡도: O(N)
